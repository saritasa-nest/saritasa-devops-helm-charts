{{ if .Values.buildkit.enabled }}
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: buildkit
  namespace: {{ .Release.Namespace }}

spec:
  description: >-
    This is task for Saritasa projects written with Dockerfile, compilation is done by using BuildKit
    https://github.com/moby/buildkit

  workspaces:
    - name: source

  params:
    - name: application
      type: string
      description: name of the argocd application we're going to deploy/sync

    - name: docker_file
      type: string
      description: name of the dockerfile
      default: "Dockerfile"

    - name: docker_context
      type: string
      description: |
         The build context used by Builder
      default: "."

    - name: extra_args
      type: array
      description: extra args to be passed into buildkit builder
      default: []

    - name: environment
      type: string
      description: environment name of the app being built, i.e. dev/staging/prod

    - name: app_image
      type: string
      description: the name of where to store the app image

  results:
    - name: app_image_digest
      description: the digest of the built `image`
    - name: app_image_url
      description: the url of the built `image`
    - name: destination_args
      description: the destination args to pass to the build task
    - name: extra_args
      description: the extra args to pass to the build task

  stepTemplate:
    envFrom:
      - configMapRef:
          name: $(params.application)-build-pipeline-config # project specific values

  steps:
    # Buildkit can't push to AWS ECR with AWS IRSA only, it needs docker-like credentials
    # https://github.com/moby/buildkit/issues/3947
    # Docker credentials file is created in manual way to avoid creating custom Docker image
    # with awscli and docker packages both installed
    - name: get-ecr-credentials
      image: {{ .Values.images.awscli }}
      imagePullPolicy: {{ .Values.imagePullPolicy }}
      workingDir: $(workspaces.source.path)
      securityContext:
        runAsNonRoot: false
        privileged: true
        allowPrivilegeEscalation: true
        capabilities:
          drop:
            - ALL
      script: |
        #!/bin/sh
        set -euo pipefail
        ecr_registry=$(echo "$(params.app_image)" | cut -d/ -f1)
        ecr_region=$(echo "$ecr_registry" | sed -n 's/.*\.ecr\.\(.*\)\.amazonaws\.com.*/\1/p')
        password=$(aws ecr get-login-password --region $ecr_region)
        auth=$(echo -n "AWS:${password}" | base64 | tr -d '\n')
        mkdir -p $(workspaces.source.path)/docker
        cat > $(workspaces.source.path)/docker/config.json <<EOF
        {
          "auths": {
            "${ecr_registry}": {
              "auth": "${auth}"
            }
          }
        }
        EOF

    - name: get-extra-args
      image: {{ .Values.images.tekton }}
      imagePullPolicy: IfNotPresent
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
        privileged: false
        allowPrivilegeEscalation: false
      args:
        - "$(params.extra_args)"
      script: |
        #!/usr/bin/env bash
        set -euo pipefail
        echo "Extra args: $@"

        # Parse extra arguments to collect the `--destination` args separately from the
        # rest ones to use later in the build task, cause it accepts multiple tags only in such a format:
        # --output type=image,\"name=303629721857.dkr.ecr.us-east-1.amazonaws.com/usummit/prod/locust:latest,303629721857.dkr.ecr.us-east-1.amazonaws.com/usummit/prod/locust:test\",push=true,buildinfo-attrs=true
        destination_args="name=$(params.app_image)"
        extra_args=""
        for arg in "$@"; do
          case "$arg" in
            --destination=*) destination="${arg#--destination=}"
                    destination_args="${destination_args:+$destination_args,}$destination" ;;
            *)      extra_args="$extra_args $arg" ;;
          esac
        done

        echo "Destination args: $destination_args"
        echo "Extra args: $extra_args"
        echo "${destination_args}" > "$(results.destination_args.path)"
        echo "${extra_args}" > "$(results.extra_args.path)"

    - name: build
      image: {{ .Values.images.buildkit }}
      imagePullPolicy: {{ .Values.imagePullPolicy }}
      securityContext:
        runAsNonRoot: false
        privileged: true
        allowPrivilegeEscalation: true
        capabilities:
          drop:
            - ALL
      workingDir: $(workspaces.source.path)
      env:
        - name: BUILDKITD_FLAGS
          value: --oci-worker-no-process-sandbox
        - name: DOCKER_CONFIG
          value: $(workspaces.source.path)/docker
      script: |
        #!/bin/sh
        set -euo pipefail
        destination_args=$(cat "$(results.destination_args.path)")
        extra_args=$(cat "$(results.extra_args.path)")
        image="$(params.app_image)"
        image_cached="${image%%:*}:cache"
        buildctl-daemonless.sh build \
          --frontend=dockerfile.v0 \
          --local context=$(workspaces.source.path)/$(params.docker_context) \
          --local dockerfile=$(workspaces.source.path)/$(params.docker_context) \
          --opt filename=$(params.docker_file) \
          --opt build-arg:ENVIRONMENT=$(params.environment) \
          --output type=image,"$destination_args",push=true,buildinfo-attrs=true \
          --metadata-file=$(workspaces.source.path)/build-metadata.json \
          --export-cache type=registry,mode=max,ref=$image_cached \
          --import-cache type=registry,ref=$image_cached \
          $extra_args

    # Extract image digest from build-metadata.json (BuildKit does not provide it automatically)
    - name: results
      image: {{ .Values.images.tekton }}
      imagePullPolicy: IfNotPresent
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
        privileged: false
        allowPrivilegeEscalation: false
      env:
        - name: app_image
          value: $(params.app_image)
      script: |
        #!/usr/bin/env bash
        set -eu
        echo -n "${app_image}" \
          | tee "$(results.app_image_url.path)"
        echo -n "$(jq -r '.["containerimage.digest"]' $(workspaces.source.path)/build-metadata.json)" \
          | tee "$(results.app_image_digest.path)"
{{ end }}
