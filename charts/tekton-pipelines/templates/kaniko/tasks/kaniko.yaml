{{ if .Values.kaniko.enabled }}
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: kaniko
  namespace: {{ .Release.Namespace }}

spec:
  description: >-
    This is task for legacy Saritasa projects written with Dockerfile, compilation is done by using Kaniko
    https://www.baeldung.com/ops/kaniko

  workspaces:
    - name: source

  params:
    {{- include "params.app" (dict "target" "task") | nindent 4 }}
    {{- include "params.registry" (dict "target" "task") | nindent 4 }}
    {{- include "params.docker" (dict "target" "task") | nindent 4 }}

  results:
    - name: password
      description: The password to authenticate to ecr registry.

  stepTemplate:
    envFrom:
      - configMapRef:
          name: $(params.application)-build-pipeline-config # project specific values

  steps:
    # google can't fix chown/chmod in kaniko for 2 years, latest test was on v1.19.2
    # https://github.com/GoogleContainerTools/kaniko/issues/2108
    - name: prepare
      image: {{ $.Values.images.bash | default "docker.io/library/bash:latest" }}
      imagePullPolicy: {{ $.Values.imagePullPolicy }}
      script: |
          #!/usr/bin/env bash
          set -e
          chown -R "1000:1000" "$(workspaces.source.path)"
      securityContext:
        privileged: true
    - name: build
      image: {{ .Values.images.kainiko | default "gcr.io/kaniko-project/executor:latest"}}
      imagePullPolicy: {{ .Values.imagePullPolicy }}
      workingDir: $(workspaces.source.path)
      env:
        - name: "DOCKER_CONFIG"
          value: "/tekton/home/.docker/"
      command:
        - /kaniko/executor
      args:
        - $(params.docker_extra_args[*])
        - --build-arg=ENVIRONMENT=$(params.environment)
        - --dockerfile=$(workspaces.source.path)/$(params.docker_file)
        - --context=$(workspaces.source.path)/$(params.docker_context)
        - --destination=$(params.app_image)
        # - --digest-file=$(results.app_image_digest.path)
        # - --verbosity=debug

      # kaniko assumes it is running as root, which means this example fails on platforms
      # that default to run containers as random uid (like OpenShift). Adding this securityContext
      # makes it explicit that it needs to run as root.
      securityContext:
        runAsUser: 0
{{ end }}
