---
# Source: saritasa-tekton-pipelines/templates/buildpacks/pipelines/buildpack.yaml
apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: buildpack-frontend-build-pipeline
  namespace: default
spec:
  description: |-
    Pipeline will only build the image utilizing buildpack-frontend task and then send notification via slack. The deployment is done via argocd

  params:

    - name: application
      type: string
      description: name of the argocd application we're going to deploy/sync

    - name: sha
      type: string
      description: sha commit ID of the image deployed in cluster

    - name: head_commit
      type: string
      description: full SHA commit ID

    - name: head_commit_message
      type: string
      description: description of the commit (by developer)

    - name: pusher_name
      type: string
      description: author name

    - name: pusher_email
      type: string
      description: author email

    - name: pusher_avatar
      type: string
      description: author url avatar image

    - name: pusher_url
      type: string
      description: author link to profile

    - name: repository_url
      type: string
      description: git repository https url

    - name: environment
      type: string
      description: environment name of the app being built, i.e. dev/staging/prod

    - name: branch
      type: string
      description: git branch

    - name: image_registry
      type: string
      description: private docker registry address

    - name: image_registry_repository
      type: string
      description: private docker registry repository address

    - name: kubernetes_repository_ssh_url
      type: string
      description: git repo for kustomize management

    - name: kubernetes_branch
      type: string
      default: main
      description: git branch for kustomize managed git repo

    - name: kubernetes_repository_kustomize_path
      type: string
      description: overlay path for kustomize call

    - name: app_image
      type: string
      description: reference to a app result image

    - name: project
      type: string
      description: name of the project, which component is deployed

    - name: namespace
      type: string
      description: project's namespace

    - name: repository_submodules
      type: string
      description: defines whether repository should be initialized with submodules or not (if false value is set, it means no repository submodules would be downloaded)
      default: "true"

    - name: buildpack_builder_image
      type: string
      description: the image on which builds will run (must include lifecycle and compatible buildpacks).

    - name: buildpack_runner_image
      type: string
      description: reference to a run image to use

    - name: source_subpath
      type: string
      description: a subpath within the `source` input where the source to build is located.
      default: ""

    - name: platform_dir
      type: string
      description: name of the platform directory. for buildpack /cnb/lifecycle/creator
      default: "platform"

    - name: buildpack_config_filename
      type: string
      description: The name of the buildpack.yml file which should be used for build
      default: "buildpack.yml"

    - name: project_config_filename
      type: string
      description: The name of the project.toml file which should be used for build
      default: "project.toml"

    - name: sentry_project_name
      type: string
      description: name of the project in Sentry

    - name: sourcemaps_dir
      type: string
      description: name of the dir where frontend sourcemaps would be stored in workspace
      default: "sourcemaps"

  workspaces:
    - name: app-source
    - name: k8s-source

  tasks:
    - name: git-clone-app-source
      taskRef:
        name: git-clone
      params:
        - name: url
          value: $(params.repository_url)
        - name: revision
          value: $(params.head_commit)
        - name: submodules
          value: $(params.repository_submodules)
      workspaces:
        - name: output
          workspace: app-source

    - name: prepare-build
      taskRef:
        name: buildpack-prepare-build
      workspaces:
        - name: source
          workspace: app-source
      params:
        - name: application
          value: "$(params.application)"
        - name: platform_dir
          value: "$(params.platform_dir)"
        - name: buildpack_config_filename
          value: "$(params.buildpack_config_filename)"
        - name: project_config_filename
          value: "$(params.project_config_filename)"

    - name: detect-nodejs-version
      taskRef:
        name: detect-nodejs-version
      workspaces:
        - name: source
          workspace: app-source
      params:
        - name: default_version
          value: "14"
      runAfter:
        - prepare-build

    - name: buildpack-frontend
      taskRef:
        name: buildpack-frontend
      workspaces:
        - name: source
          workspace: app-source
      params:
        - name: application
          value: "$(params.application)"
        - name: branch
          value: "$(params.branch)"
        - name: builder_image
          value: "$(params.buildpack_builder_image)"
        - name: run_image
          value: "$(params.buildpack_runner_image)"
        - name: app_image
          value: "$(params.app_image)"
        - name: image_registry
          value: $(params.image_registry)
        - name: cache
          value: $(params.application)-buildpacks-cache
        - name: source_subpath
          value: "$(params.source_subpath)"
        - name: platform_dir
          value: "$(params.platform_dir)"
        - name: buildpack_config_filename
          value: "$(params.buildpack_config_filename)"
        - name: project_config_filename
          value: "$(params.project_config_filename)"
        - name: node_version
          value: "$(tasks.detect-nodejs-version.results.node-version)"
        - name: environment
          value: "$(params.environment)"
        - name: sourcemaps_dir
          value: "$(params.sourcemaps_dir)"
      # results:
      # - name: app_image_digest
      #   description: Result app image digest
      runAfter:
        - detect-nodejs-version

    - name: git-clone-k8s-source
      taskRef:
        name: git-clone
      params:
        - name: url
          value: $(params.kubernetes_repository_ssh_url)
        - name: revision
          value: $(params.kubernetes_branch)
      workspaces:
        - name: output
          workspace: k8s-source

    - name: kustomize
      taskRef:
        name: kustomize
      workspaces:
        - name: source
          workspace: k8s-source
      params:
        - name: application
          value: "$(params.application)"
        - name: image
          value: "$(params.app_image)"
        - name: kustomize_overlay_path
          value: "$(params.kubernetes_repository_kustomize_path)"
        - name: kubernetes_branch
          value: "$(params.kubernetes_branch)"
        - name: environment
          value: "$(params.environment)"
      runAfter:
        - buildpack-frontend

    - name: deploy
      taskRef:
        name: argocd-deploy
      params:
        - name : application
          value: "$(params.application)"
      runAfter:
        - kustomize




    - name: post-deploy
      taskRef:
        name:  buildpack-frontend-build-pipeline-post-deploy
      params:
        - name: application
          value: "$(params.application)"
        - name: project
          value: "$(params.project)"
        - name: namespace
          value: "$(params.namespace)"
        - name: sha
          value: "$(params.sha)"
        - name: environment
          value: "$(params.environment)"
      runAfter:
        -  deploy


  finally:
    - name: slack-notification
      taskRef:
        name: slack-notification
      params:
        - name: application
          value: "$(params.application)"
        - name: sha
          value: "$(params.sha)"
        - name: head_commit
          value: "$(params.head_commit)"
        - name: head_commit_message
          value: "$(params.head_commit_message)"
        - name: pusher_name
          value: "$(params.pusher_name)"
        - name: pusher_email
          value: "$(params.pusher_email)"
        - name: pusher_avatar
          value: "$(params.pusher_avatar)"
        - name: pusher_url
          value: "$(params.pusher_url)"
        - name: repository_url
          value: "$(params.repository_url)"
        - name: branch
          value: "$(params.branch)"
        - name: environment
          value: "$(params.environment)"
        - name: status
          value: "$(tasks.deploy.status)"
---
# Source: saritasa-tekton-pipelines/templates/kaniko/pipeline.yaml
apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: kaniko-build-pipeline
  namespace: default
spec:
  description: >-
    Pipeline will only build the image utilizing dockerfile using kaniko and then send notification via slack.
    The deployment is done via argocd

  params:

    - name: application
      type: string
      description: name of the argocd application we're going to deploy/sync

    - name: sha
      type: string
      description: sha commit ID of the image deployed in cluster

    - name: head_commit
      type: string
      description: full SHA commit ID

    - name: head_commit_message
      type: string
      description: description of the commit (by developer)

    - name: pusher_name
      type: string
      description: author name

    - name: pusher_email
      type: string
      description: author email

    - name: pusher_avatar
      type: string
      description: author url avatar image

    - name: pusher_url
      type: string
      description: author link to profile

    - name: repository_url
      type: string
      description: git repository https url

    - name: environment
      type: string
      description: environment name of the app being built, i.e. dev/staging/prod

    - name: branch
      type: string
      description: git branch

    - name: image_registry
      type: string
      description: private docker registry address

    - name: image_registry_repository
      type: string
      description: private docker registry repository address

    - name: kubernetes_repository_ssh_url
      type: string
      description: git repo for kustomize management

    - name: kubernetes_branch
      type: string
      default: main
      description: git branch for kustomize managed git repo

    - name: kubernetes_repository_kustomize_path
      type: string
      description: overlay path for kustomize call

    - name: app_image
      type: string
      description: reference to a app result image

    - name: project
      type: string
      description: name of the project, which component is deployed

    - name: namespace
      type: string
      description: project's namespace

    - name: docker_file
      type: string
      default: Dockerfile
      description: location of the dockerfile, should be Dockerfile if it is in the root of the repository

    - name: docker_context
      type: string
      default: "."
      description: dockerfile context path

    - name: kaniko_extra_args
      type: string
      description: extra args to be passed into kaniko builder
      default: ''

    - name: sentry_project_name
      type: string
      description: name of the project in Sentry

    - name: sourcemaps_dir
      type: string
      description: name of the dir where frontend sourcemaps would be stored in workspace
      default: "sourcemaps"

  workspaces:
    - name: app-source
    - name: k8s-source

  tasks:
    - name: kaniko
      taskRef:
        name: kaniko
      # results:
      #   - name: app_image_digest
      params:
        - name: application
          value: "$(params.application)"
        - name: image_registry
          value: $(params.image_registry)
        - name: environment
          value: "$(params.environment)"
        - name: docker_file
          value: "$(params.registry_file)"
        - name: docker_context
          value: "$(params.registry_context)"
        - name: extra_args
          value:
            - $(params.kaniko_extra_args)
        - name: app_image
          value: "$(params.app_image)"
      workspaces:
        - name: source
          workspace: app-source

    - name: git-clone-k8s-source
      taskRef:
        name: git-clone
      workspaces:
        - name: output
          workspace: k8s-source
      params:
        - name: url
          value: $(params.kubernetes_repository_ssh_url)
        - name: revision
          value: $(params.kubernetes_branch)

    - name: kustomize
      taskRef:
        name: kustomize
      workspaces:
        - name: source
          value: k8s-source
      params:
        - name: application
          value: "$(params.application)"
        - name: image
          value: "$(params.app_image)"
        - name: kustomize_overlay_path
          value: "$(params.kubernetes_repository_kustomize_path)"
        - name: kubernetes_branch
          value: "$(params.kubernetes_branch)"
        - name: environment
          value: "$(params.environment)"
      runAfter:
        - kaniko

    - name: deploy
      taskRef:
        name: argocd-deploy
      params:
        - name : application
          value: "$(params.application)"
      runAfter:
        - kustomize




    - name: post-deploy
      taskRef:
        name:  kaniko-post-deploy
      params:
        - name: application
          value: "$(params.application)"
        - name: project
          value: "$(params.project)"
        - name: namespace
          value: "$(params.namespace)"
        - name: sha
          value: "$(params.sha)"
        - name: environment
          value: "$(params.environment)"
      runAfter:
        -  deploy


  finally:
    - name: slack-notification
      taskRef:
        name: slack-notification
      params:
        - name: application
          value: "$(params.application)"
        - name: sha
          value: "$(params.sha)"
        - name: head_commit
          value: "$(params.head_commit)"
        - name: head_commit_message
          value: "$(params.head_commit_message)"
        - name: pusher_name
          value: "$(params.pusher_name)"
        - name: pusher_email
          value: "$(params.pusher_email)"
        - name: pusher_avatar
          value: "$(params.pusher_avatar)"
        - name: pusher_url
          value: "$(params.pusher_url)"
        - name: repository_url
          value: "$(params.repository_url)"
        - name: branch
          value: "$(params.branch)"
        - name: environment
          value: "$(params.environment)"
        - name: status
          value: "$(tasks.deploy.status)"
---
# Source: saritasa-tekton-pipelines/templates/buildpacks/tasks/buildpack.yaml
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: buildpack-frontend
  namespace: default
spec:
  description: |-
    The Buildpacks buildpack-frontend task builds source into a container image and pushes it to a AWS ECR registry, using Cloud Native Buildpacks

  workspaces:
    - name: source

  params:
    - name: application
      type: string
      description: name of the argocd application we're going to deploy/sync

    - name: branch
      type: string
      description: the git branch we build

    - name: builder_image
      type: string
      description: the image on which builds will run (must include lifecycle and compatible buildpacks).

    - name: run_image
      type: string
      description: reference to a run image to use
      default: ""

    - name: app_image
      type: string
      description: reference to a result app image

    - name: image_registry
      type: string
      description: private docker registry address

    - name: cache
      type: string
      description: the name of the persistent app cache volume.
      default: empty-dir

    - name: cache_image
      type: string
      description: the name of the persistent app cache image.
      default: ""

    - name: node_version
      type: string
      description: nodejs version of the image used to build static
      default: "14"

    - name: platform_dir
      type: string
      description: the name of the platform directory.

    - name: buildpack_config_filename
      type: string
      description: The name of the buildpack.yml file which should be used for build
      default: "buildpack.yml"

    - name: project_config_filename
      type: string
      description: The name of the project.toml file which should be used for build
      default: "project.toml"

    - name: user_id
      type: string
      description: the user id of the builder image user.
      default: "1000"

    - name: group_id
      type: string
      description: the group id of the builder image user.
      default: "1000"

    - name: process_type
      type: string
      description: the default process type to set on the image.
      default: "web"

    - name: source_subpath
      type: string
      description: a subpath within the `source` input where the source to build is located.
      default: ""

    - name: skip_restore
      type: string
      description: do not write layer metadata or restore cached layers
      default: "false"

    - name: environment
      type: string
      description: environment name of the app being built, i.e. dev/staging/prod

    # below parameter is used at the end of `build-static` tasks (defined in values.yaml)
    # for `frontend` build to store built static to `/workspace/source/sourcemaps/`
    # dir for further usage in `sentry-release` task
    - name: sourcemaps_dir
      type: string
      description: name of the dir where frontend sourcemaps would be stored in workspace
      default: "sourcemaps"

  # results:
  #   - name: app_image_digest
  #     description: Image digest result after build
  #   - name: app_image_url
  #     description: Image url result after build

  stepTemplate:
    env:
      - name: CNB_PLATFORM_API
        value: "0.4"
    envFrom:
      - configMapRef:
          name: $(params.application)-build-pipeline-config # project specific values

  steps:
    - name: prepare
      image: docker.io/library/bash:5.1.8
      imagePullPolicy: IfNotPresent
      script: |
          #!/usr/bin/env bash
          set -e
          chown -R "$(params.user_id):$(params.group_id)" "/tekton/home" &&
          chown -R "$(params.user_id):$(params.group_id)" "/layers" &&
          chown -R "$(params.user_id):$(params.group_id)" "/cache" &&
          chown -R "$(params.user_id):$(params.group_id)" "$(workspaces.source.path)"
      volumeMounts:
        - name: layers-dir
          mountPath: /layers
        - name: $(params.cache)
          mountPath: /cache
      securityContext:
        privileged: true

    # insert customized steps as defined in the values.yaml of the helm chart
    - computeResources:
        limits:
          cpu: 512m
          memory: 1Gi
        requests:
          cpu: 250m
          memory: 500Mi
      image: first-step-image
      imagePullPolicy: IfNotPresent
      name: first-step
      script: |
        #!/bin/bash
        echo First Step
      workingDir: $(workspaces.source.path)
    - computeResources:
        limits:
          cpu: 512m
          memory: 1Gi
        requests:
          cpu: 250m
          memory: 500Mi
      image: second-step-image
      imagePullPolicy: IfNotPresent
      name: second-step
      script: |
        #!/bin/bash
        echo Second Step
      workingDir: $(workspaces.source.path)

    # if you need to debug this step you can do:
    # insert `sleep 3000` after the aws ecr get-login-password command and then get inside the container
    # k exec -ti `k --no-headers=true get pods -l tekton.dev/task=buildpack | awk '{print $1}'` -c step-create bash
    - name: build
      image: $(params.builder_image)
      imagePullPolicy: IfNotPresent
      workingDir: $(workspaces.source.path)
      script: |
        #!/bin/bash

        aws ecr get-login-password --region $AWS_REGION | docker login -u AWS --password-stdin $(params.image_registry)

        /cnb/lifecycle/creator \
          -app=$(params.source_subpath) \
          -project-metadata=project.toml \
          -cache-dir=/cache \
          -layers=/layers \
          -platform=$(workspaces.source.path)/$(params.platform_dir) \
          -report=/layers/report.toml \
          -cache-image=$(params.cache_image) \
          -uid=$(params.user_id) \
          -gid=$(params.group_id) \
          -process-type=$(params.process_type) \
          -skip-restore=$(params.skip_restore) \
          -previous-image=$(params.app_image) \
          -run-image=$(params.run_image) \
          $(params.app_image)

      volumeMounts:
        - name: layers-dir
          mountPath: /layers
        - name: $(params.cache)
          mountPath: /cache
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000

    # - name: results
    #   image: docker.io/library/bash:5.1.4@sha256:b208215a4655538be652b2769d82e576bc4d0a2bb132144c060efc5be8c3f5d6
    #   script: |
    #     #!/usr/bin/env bash
    #     set -e
    #     grep "digest" /layers/report.toml | cut -d'"' -f2 | cut -d'"' -f2 | tr -d '\n' | tee "$(results.app_image_digest.path)"
    #     echo -n "$(params.app_image)" | tee "$(results.app_image_url.path)"
      volumeMounts:
        - name: layers-dir
          mountPath: /layers

  volumes:
    - name: empty-dir
      emptyDir: {}
    - name: layers-dir
      emptyDir: {}
---
# Source: saritasa-tekton-pipelines/templates/buildpacks/tasks/post-deploy.yaml
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: buildpack-frontend-build-pipeline-post-deploy
  namespace: default

spec:
  description: >-
    Task performs custom post deploy actions, which are set from values.yaml
    (for ex. run selenium tests or etc)

  params:

    - name: application
      type: string
      description: name of the argocd application we're going to deploy/sync

    - name: project
      type: string
      description: name of the project, which component is deployed

    - name: namespace
      type: string
      description: project's namespace

    - name: sha
      type: string
      description: sha commit ID of the image deployed in cluster

    - name: environment
      type: string
      description: environment name of the app being built, i.e. dev/staging/prod

  stepTemplate:
    envFrom:
      - configMapRef:
          name: $(params.application)-build-pipeline-config # project specific values

  steps:
    - name: argo-events
      image: badouralix/curl-jq
      imagePullPolicy: IfNotPresent
      script: |
        #!/usr/bin/env sh

        # Env contains params passed from '*-build-pipeline-config' ConfigMap,
        # here we convert them to lowercased json and pass to JSON_PAYLOAD as 'extra'.

        # This workflow allows us to pass any dynamic custom parameters needed to argo-events
        # sensors without changing tekton helm charts all the time, so any project may have
        # any custom parameter, which will be passed to argo-events and then corresponding Sensor
        # would be triggered based on this 'extra' params.
        EXTRA=$(jq -n env | jq 'walk(if type=="object" then with_entries(.key|=ascii_downcase) else . end)')
        JSON_TEMPLATE='{
          "namespace": "$(params.namespace)",
          "project": "$(params.project)",
          "environment": "$(params.environment)",
          "application": "$(params.application)",
          "sha": "$(params.sha)",
          "extra": %s
        }'
        JSON_PAYLOAD=$(printf "$JSON_TEMPLATE" "$EXTRA")

        echo "Payload: $JSON_PAYLOAD"

        OUTPUT=$(curl -s -o /dev/null -w httpcode=%{http_code} --location \
          --request POST "build-succeed-eventsource-svc.argo-events.svc.cluster.local:12000/build-succeed" \
          --header 'Content-Type: application/json' \
          --data-raw "$JSON_PAYLOAD")

        STATUS_CODE=$(echo "${OUTPUT}" | sed -e 's/.*\httpcode=//')
        if [ ${STATUS_CODE} -ne 204 ] && [ ${STATUS_CODE} -ne 200 ]; then
            echo "Curl operation/command failed due to server return code - ${STATUS_CODE}"
            exit 0
        fi

        echo "Sent 'build-succeed' webhook"

  # insert customized steps as defined in the values.yaml of the helm chart
---
# Source: saritasa-tekton-pipelines/templates/buildpacks/tasks/prepare-buildpack-build.yaml
# TODO:
#
# 1. Try to remove `set` step in `buildpack-prepare-build` task once below
# issues would be fixed or Tekton engine upgrade will allow us to do that in a
# better way:
#
# https://github.com/tektoncd/catalog/blob/main/task/buildpacks/0.3/buildpacks.yaml#L68-L113
#
# but we should use it until this is resolved:
# - https://github.com/buildpacks/tekton-integration/issues/33
# - https://github.com/buildpacks/tekton-integration/issues/32
#
# 2. Try to remove `prepare` step in `buildpack-prepare-build` task and logics
# to pass different file names for `buildpack.yml` and `project.toml` with
# `buildpack_config_filename` and `project_config_filename` vars once Tekton
# engine would be upgraded. If `cnb lifecycle` won't allow to do that even after
# Tekton upgrade, we can try to build projects with `pack` instead.

apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: buildpack-prepare-build
  namespace: default
spec:
  description: >-
    This task prepares project contents to build process:
      - determines which `project.toml` and `buildpack.yaml` files should be
        used for a build
      - parses project.toml file and stores its environment variables values to
        platform dir for further processing by buildpack task.

  workspaces:
    - name: source

  params:
    - name: application
      type: string
      description: name of the argocd application we're going to deploy/sync

    - name: platform_dir
      type: string
      description: The name of the platform directory.

    - name: buildpack_config_filename
      type: string
      description: The name of the buildpack.yml file which should be used for build

    - name: project_config_filename
      type: string
      description: The name of the project.toml file which should be used for build

  steps:

    - name: prepare
      image: docker.io/library/bash:5.1.8
      imagePullPolicy: IfNotPresent
      script: |
        #!/usr/bin/env bash

        path=$(workspaces.source.path)

        # rename `buildpack_config_filename` file to `buildpack.yml` and
        # `project_config_filename` to `project.toml` if they are not equal to
        # defaults (buildpack.yml, project.toml)
        if [[ $(params.buildpack_config_filename) != "buildpack.yml" ]]; then
          mv $path/$(params.buildpack_config_filename) $path/buildpack.yml
          echo "Rename $path/$(params.buildpack_config_filename) to $path/buildpack.yml"
        fi

        if [[ $(params.project_config_filename) != "project.toml" ]]; then
          mv $path/$(params.project_config_filename) $path/project.toml
          echo "Rename $path/$(params.project_config_filename) to $path/project.toml"
        fi

    - name: clean
      image: docker.io/library/bash:5.1.8
      imagePullPolicy: IfNotPresent
      script: |
        #!/usr/bin/env bash
        # clean platform env dir before new run, so when env var is removed from project.toml file
        # it wouldn't influence the build
        set -e

        ENV_PATH=$(workspaces.source.path)/$(params.platform_dir)/env

        if [ -d $ENV_PATH ]; then
          echo "clean everything from $ENV_PATH"
          rm -f $ENV_PATH/*
        fi

    - name: set
      image: saritasallc/python3:0.4
      imagePullPolicy: IfNotPresent
      script: |
        #!/usr/bin/env python3

        import toml, os, sys

        source_path = "$(workspaces.source.path)/project.toml"
        env_dir = "$(workspaces.source.path)/$(params.platform_dir)/env"

        try:
          with open(source_path, "r") as f:
            settings = toml.load(f)
        except FileNotFoundError:
          quit()
        except Exception as e:
          raise Exception("Unable to parse project.toml file\nTraceback: {e}")

        env_vars = settings.get("build", {}).get("env", [])
        env_vars = {item["name"]: item["value"] for item in env_vars}

        # create directory if not exists
        if env_vars and not os.path.exists(env_dir):
            os.makedirs(env_dir)

        # create env variables files
        for name, value in env_vars.items():
          with open(f"{env_dir}/{name}", "w") as f:
            f.write(value)
            print(
              f"Created `{env_dir}/{name}` var file with `{value}` value",
              file=sys.stdout
            )
---
# Source: saritasa-tekton-pipelines/templates/common/tasks/argocd-deploy.yaml
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: argocd-deploy
  namespace: default

spec:
  description: >-
    The task parses project.toml file and stores its environment variables
    values to platform dir for further processing by buildpack task.

  params:
    - name: application
      type: string
      description: name of the argocd application we're going to deploy/sync

  stepTemplate:
    envFrom:
      - configMapRef:
          name: $(params.application)-build-pipeline-config # project specific values
      - secretRef:
          name: $(params.application)-argocd-secret  # used for authentication (username/password or auth token)
  steps:
    - name: deploy
      image: cfmanteiga/alpine-bash-curl-jq
      imagePullPolicy: IfNotPresent
      script: |
        #!/usr/bin/env bash
        set +x
        curl --silent --location -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/download/v2.3.4/argocd-linux-amd64
        chmod +x /usr/local/bin/argocd

        # connect to private service
        # instead of connecting through a public ingress
        yes | argocd login argo-cd-argocd-server.argo-cd \
          --insecure \
          --grpc-web \
          --grpc-web-root-path $ARGOCD_ROOT_PATH \
          --username $ARGOCD_USERNAME \
          --password $ARGOCD_PASSWORD \
          --http-retry-max 3

        argocd app sync $(params.application) \
          --server=argo-cd-argocd-server.argo-cd

        argocd app wait $(params.application) \
          --server=argo-cd-argocd-server.argo-cd \
          --health=true \
          --operation=true

        synced=`argocd app get $(params.application) --server=argo-cd-argocd-server.argo-cd -o json | jq -r '.status.sync.status' | awk '{print tolower($1)}'`
        healthy=`argocd app get $(params.application) --server=argo-cd-argocd-server.argo-cd -o json | jq -r '.status.health.status' | awk '{print tolower($1)}'`

        [[ "$synced" == "synced" ]] && [[ "$healthy" == "healthy" ]] && echo "Sync completed succcessfully. App is healthy!" || (echo "Sync failed" && exit 1)
---
# Source: saritasa-tekton-pipelines/templates/common/tasks/detect-nodejs-version.yaml
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: detect-nodejs-version
  namespace: default
spec:
  description: >-
    Nodejs version detected from package.json

  workspaces:
    - name: source

  params:
    - name: default_version
      type: string
      description: nodejs default version to be used if not detected in package.json

  results:
    - name: node-version
      description: Nodejs version detected from package.json

  steps:
    - name: get-nodejs-version
      image: cfmanteiga/alpine-bash-curl-jq
      imagePullPolicy: IfNotPresent
      workingDir: $(workspaces.source.path)
      script: |
        #!/usr/bin/env bash
        set -Eeo pipefail

        if [ ! -f package.json ]; then
          echo "no package.json file found"
          echo -n "$(params.default_version)" > $(results.node-version.path)
          exit 0
        fi

        # if no engine is defined we use node:14 as the default image
        node_ver=$(cat package.json | jq -r ".engines.node // 14" | sed 's/[\^>~=]//g')

        # store in the results
        # which we will use as the image:"node:version" in build task
        # later in the pipeline
        echo -n "$node_ver" > $(results.node-version.path)
        echo "detected node version: $node_ver"
---
# Source: saritasa-tekton-pipelines/templates/common/tasks/git-clone.yaml
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: git-clone
  labels:
    app.kubernetes.io/version: "0.9"
  annotations:
    tekton.dev/pipelines.minVersion: "0.38.0"
    tekton.dev/categories: Git
    tekton.dev/tags: git
    tekton.dev/displayName: "git clone"
    tekton.dev/platforms: "linux/amd64,linux/s390x,linux/ppc64le,linux/arm64"
spec:
  description: >-
    These Tasks are Git tasks to work with repositories used by other tasks
    in your Pipeline.

    The git-clone Task will clone a repo from the provided url into the
    output Workspace. By default the repo will be cloned into the root of
    your Workspace. You can clone into a subdirectory by setting this Task's
    subdirectory param. This Task also supports sparse checkouts. To perform
    a sparse checkout, pass a list of comma separated directory patterns to
    this Task's sparseCheckoutDirectories param.
  workspaces:
    - name: output
      description: The git repo will be cloned onto the volume backing this Workspace.
    - name: ssh-directory
      optional: true
      description: |
        A .ssh directory with private key, known_hosts, config, etc. Copied to
        the user's home before git commands are executed. Used to authenticate
        with the git remote when performing the clone. Binding a Secret to this
        Workspace is strongly recommended over other volume types.
    - name: basic-auth
      optional: true
      description: |
        A Workspace containing a .gitconfig and .git-credentials file. These
        will be copied to the user's home before any git commands are run. Any
        other files in this Workspace are ignored. It is strongly recommended
        to use ssh-directory over basic-auth whenever possible and to bind a
        Secret to this Workspace over other volume types.
    - name: ssl-ca-directory
      optional: true
      description: |
        A workspace containing CA certificates, this will be used by Git to
        verify the peer with when fetching or pushing over HTTPS.
  params:
    - name: url
      description: Repository URL to clone from.
      type: string
    - name: revision
      description: Revision to checkout. (branch, tag, sha, ref, etc...)
      type: string
      default: ""
    - name: refspec
      description: Refspec to fetch before checking out revision.
      default: ""
    - name: submodules
      description: Initialize and fetch git submodules.
      type: string
      default: "true"
    - name: depth
      description: Perform a shallow clone, fetching only the most recent N commits.
      type: string
      default: "1"
    - name: sslVerify
      description: Set the `http.sslVerify` global git config. Setting this to `false` is not advised unless you are sure that you trust your git remote.
      type: string
      default: "true"
    - name: crtFileName
      description: file name of mounted crt using ssl-ca-directory workspace. default value is ca-bundle.crt.
      type: string
      default: "ca-bundle.crt"
    - name: subdirectory
      description: Subdirectory inside the `output` Workspace to clone the repo into.
      type: string
      default: ""
    - name: sparseCheckoutDirectories
      description: Define the directory patterns to match or exclude when performing a sparse checkout.
      type: string
      default: ""
    - name: deleteExisting
      description: Clean out the contents of the destination directory if it already exists before cloning.
      type: string
      default: "true"
    - name: httpProxy
      description: HTTP proxy server for non-SSL requests.
      type: string
      default: ""
    - name: httpsProxy
      description: HTTPS proxy server for SSL requests.
      type: string
      default: ""
    - name: noProxy
      description: Opt out of proxying HTTP/HTTPS requests.
      type: string
      default: ""
    - name: verbose
      description: Log the commands that are executed during `git-clone`'s operation.
      type: string
      default: "true"
    - name: gitInitImage
      description: The image providing the git-init binary that this Task runs.
      type: string
      default: "gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.40.2"
    - name: userHome
      description: |
        Absolute path to the user's home directory.
      type: string
      default: "/home/git"
  results:
    - name: commit
      description: The precise commit SHA that was fetched by this Task.
    - name: url
      description: The precise URL that was fetched by this Task.
    - name: committer-date
      description: The epoch timestamp of the commit that was fetched by this Task.
  steps:
    - name: clone
      image: "$(params.gitInitImage)"
      env:
      - name: HOME
        value: "$(params.userHome)"
      - name: PARAM_URL
        value: $(params.url)
      - name: PARAM_REVISION
        value: $(params.revision)
      - name: PARAM_REFSPEC
        value: $(params.refspec)
      - name: PARAM_SUBMODULES
        value: $(params.submodules)
      - name: PARAM_DEPTH
        value: $(params.depth)
      - name: PARAM_SSL_VERIFY
        value: $(params.sslVerify)
      - name: PARAM_CRT_FILENAME
        value: $(params.crtFileName)
      - name: PARAM_SUBDIRECTORY
        value: $(params.subdirectory)
      - name: PARAM_DELETE_EXISTING
        value: $(params.deleteExisting)
      - name: PARAM_HTTP_PROXY
        value: $(params.httpProxy)
      - name: PARAM_HTTPS_PROXY
        value: $(params.httpsProxy)
      - name: PARAM_NO_PROXY
        value: $(params.noProxy)
      - name: PARAM_VERBOSE
        value: $(params.verbose)
      - name: PARAM_SPARSE_CHECKOUT_DIRECTORIES
        value: $(params.sparseCheckoutDirectories)
      - name: PARAM_USER_HOME
        value: $(params.userHome)
      - name: WORKSPACE_OUTPUT_PATH
        value: $(workspaces.output.path)
      - name: WORKSPACE_SSH_DIRECTORY_BOUND
        value: $(workspaces.ssh-directory.bound)
      - name: WORKSPACE_SSH_DIRECTORY_PATH
        value: $(workspaces.ssh-directory.path)
      - name: WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND
        value: $(workspaces.basic-auth.bound)
      - name: WORKSPACE_BASIC_AUTH_DIRECTORY_PATH
        value: $(workspaces.basic-auth.path)
      - name: WORKSPACE_SSL_CA_DIRECTORY_BOUND
        value: $(workspaces.ssl-ca-directory.bound)
      - name: WORKSPACE_SSL_CA_DIRECTORY_PATH
        value: $(workspaces.ssl-ca-directory.path)
      securityContext:
        runAsNonRoot: true
        runAsUser: 65532
      script: |
        #!/usr/bin/env sh
        set -eu

        if [ "${PARAM_VERBOSE}" = "true" ] ; then
          set -x
        fi

        if [ "${WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND}" = "true" ] ; then
          cp "${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.git-credentials" "${PARAM_USER_HOME}/.git-credentials"
          cp "${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.gitconfig" "${PARAM_USER_HOME}/.gitconfig"
          chmod 400 "${PARAM_USER_HOME}/.git-credentials"
          chmod 400 "${PARAM_USER_HOME}/.gitconfig"
        fi

        if [ "${WORKSPACE_SSH_DIRECTORY_BOUND}" = "true" ] ; then
          cp -R "${WORKSPACE_SSH_DIRECTORY_PATH}" "${PARAM_USER_HOME}"/.ssh
          chmod 700 "${PARAM_USER_HOME}"/.ssh
          chmod -R 400 "${PARAM_USER_HOME}"/.ssh/*
        fi

        if [ "${WORKSPACE_SSL_CA_DIRECTORY_BOUND}" = "true" ] ; then
           export GIT_SSL_CAPATH="${WORKSPACE_SSL_CA_DIRECTORY_PATH}"
           if [ "${PARAM_CRT_FILENAME}" != "" ] ; then
              export GIT_SSL_CAINFO="${WORKSPACE_SSL_CA_DIRECTORY_PATH}/${PARAM_CRT_FILENAME}"
           fi
        fi
        CHECKOUT_DIR="${WORKSPACE_OUTPUT_PATH}/${PARAM_SUBDIRECTORY}"

        cleandir() {
          # Delete any existing contents of the repo directory if it exists.
          #
          # We don't just "rm -rf ${CHECKOUT_DIR}" because ${CHECKOUT_DIR} might be "/"
          # or the root of a mounted volume.
          if [ -d "${CHECKOUT_DIR}" ] ; then
            # Delete non-hidden files and directories
            rm -rf "${CHECKOUT_DIR:?}"/*
            # Delete files and directories starting with . but excluding ..
            rm -rf "${CHECKOUT_DIR}"/.[!.]*
            # Delete files and directories starting with .. plus any other character
            rm -rf "${CHECKOUT_DIR}"/..?*
          fi
        }

        if [ "${PARAM_DELETE_EXISTING}" = "true" ] ; then
          cleandir || true
        fi

        test -z "${PARAM_HTTP_PROXY}" || export HTTP_PROXY="${PARAM_HTTP_PROXY}"
        test -z "${PARAM_HTTPS_PROXY}" || export HTTPS_PROXY="${PARAM_HTTPS_PROXY}"
        test -z "${PARAM_NO_PROXY}" || export NO_PROXY="${PARAM_NO_PROXY}"

        git config --global --add safe.directory "${WORKSPACE_OUTPUT_PATH}"
        /ko-app/git-init \
          -url="${PARAM_URL}" \
          -revision="${PARAM_REVISION}" \
          -refspec="${PARAM_REFSPEC}" \
          -path="${CHECKOUT_DIR}" \
          -sslVerify="${PARAM_SSL_VERIFY}" \
          -submodules="${PARAM_SUBMODULES}" \
          -depth="${PARAM_DEPTH}" \
          -sparseCheckoutDirectories="${PARAM_SPARSE_CHECKOUT_DIRECTORIES}"
        cd "${CHECKOUT_DIR}"
        RESULT_SHA="$(git rev-parse HEAD)"
        EXIT_CODE="$?"
        if [ "${EXIT_CODE}" != 0 ] ; then
          exit "${EXIT_CODE}"
        fi
        RESULT_COMMITTER_DATE="$(git log -1 --pretty=%ct)"
        printf "%s" "${RESULT_COMMITTER_DATE}" > "$(results.committer-date.path)"
        printf "%s" "${RESULT_SHA}" > "$(results.commit.path)"
        printf "%s" "${PARAM_URL}" > "$(results.url.path)"
---
# Source: saritasa-tekton-pipelines/templates/common/tasks/kustomize.yaml
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: kustomize
  namespace: default
spec:
  description: >-
    Updates image tag in the kustomize overlay of the app

  workspaces:
    - name: source

  params:
    - name: application
      type: string
      description: name of the argocd application we're going to deploy/sync

    - name: image
      type: string
      description: new image for the application

    - name: kustomize_overlay_path
      type: string
      description: overlay path for kustomize call

    - name: kubernetes_branch
      default: "main"

    - name: environment
      type: string
      description: environment name of the app being built, i.e. dev/staging/prod

  stepTemplate:
    envFrom:
      - configMapRef:
          name: $(params.application)-build-pipeline-config

  steps:
    - name: git-set-user
      image: alpine/git:v2.32.0
      imagePullPolicy: IfNotPresent
      workingDir: $(workspaces.source.path)
      script: |
        git config user.email "$DEVOPS_GROUP_EMAIL"
        git config user.name "tekton-kustomize"

    - name: update-image
      image: registry.k8s.io/kustomize/kustomize:v5.0.0
      imagePullPolicy: IfNotPresent
      workingDir: $(workspaces.k8s-source.path)
      script: |
        app=$(params.application)
        env=$(params.environment)
        application=${app%-$env}
        cd $(params.kustomize_overlay_path) && \
          /app/kustomize edit set image $application=$(params.image)

    - name: yamlfix
      image: public.ecr.aws/saritasa/yamlfix:1.8.1
      imagePullPolicy: IfNotPresent
      workingDir: $(workspaces.source.path)
      script: |
        CONFIG=/workdir/yamlfix.toml
        if [ -f .yamlfix.toml ]; then
          CONFIG=$(realpath .yamlfix.toml)
        fi

        find $(params.kustomize_overlay_path) -iname "*.yaml" -exec yamlfix --config-file=$CONFIG {} \;

    - name: kubeval
      image: public.ecr.aws/saritasa/kubeval:0.16.1
      imagePullPolicy: IfNotPresent
      workingDir: $(workspaces.source.path)
      script: |
        APISERVER=https://kubernetes.default.svc
        SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount
        TOKEN=$(cat ${SERVICEACCOUNT}/token)
        CACERT=${SERVICEACCOUNT}/ca.crt
        KUBERNETES_INFO=$(curl --cacert ${CACERT} --header "Authorization: Bearer ${TOKEN}" -X GET ${APISERVER}/version)
        KUBERNETES_VERSION=$(echo $KUBERNETES_INFO | jq -r ".gitVersion" | grep -oE '\d\d?\.\d\d?\.\d\d?')

        export KUBEVAL_SCHEMA_LOCATION=https://raw.githubusercontent.com/yannh/kubernetes-json-schema/master
        kustomize build $(params.kustomize_overlay_path) | kubeval --ignore-missing-schemas --kubernetes-version=$KUBERNETES_VERSION -f -

    - name: git-push
      image: alpine/git:v2.32.0
      imagePullPolicy: IfNotPresent
      workingDir: $(workspaces.source.path)
      script: |
        set +x
        git checkout $(params.kubernetes_branch)

        # apply changes only if it exists, otherwise do nothing
        if [ $(git status --porcelain | wc -l) -eq 0 ]; then
          echo "There are no changes, nothing to commit"
          exit
        fi
        git commit -am "feat: $(params.environment) argocd deployment $(params.kustomize_overlay_path), new image: $(params.image)"
        # define retry delays appropriate for dash
        set -- "0" "1" "3" "5"
        for DELAY
        do
          if [ "$DELAY" != "0" ]; then
            echo "retry in ${DELAY}s"
          fi
          sleep $DELAY

          # check whether there are changes between local and remote
          git fetch origin $(params.kubernetes_branch)
          LOCAL_COMMIT=`git rev-parse @`
          REMOTE_COMMIT=`git rev-parse origin/$(params.kubernetes_branch)`
          if [ $LOCAL_COMMIT != $REMOTE_COMMIT ]; then
            echo "Need to pull new changes"
            git pull --rebase origin $(params.kubernetes_branch)
          fi
          git push origin $(params.kubernetes_branch) && break || true
        done
---
# Source: saritasa-tekton-pipelines/templates/common/tasks/slack-notification.yaml
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: slack-notification
  namespace: default

spec:
  description: >-
    Send slack notification with various information about pipeline progress/result.
    You can see my question about dealing with task status here: https://github.com/tektoncd/pipeline/issues/3762

  params:

    - name: application
      type: string
      description: name of the argocd application we're going to deploy/sync

    - name: sha
      type: string
      description: sha commit ID of the image deployed in cluster

    - name: head_commit
      type: string
      description: full SHA commit ID

    - name: head_commit_message
      type: string
      description: description of the commit (by developer)

    - name: pusher_name
      type: string
      description: author name

    - name: pusher_email
      type: string
      description: author email

    - name: pusher_avatar
      type: string
      description: author url avatar image

    - name: pusher_url
      type: string
      description: author link to profile

    - name: repository_url
      type: string
      description: git repository https url

    - name: environment
      type: string
      description: environment name of the app being built, i.e. dev/staging/prod

    - name: branch
      type: string
      description: git branch

    - name: status
      type: string
      description: status of the deployment (i.e. "succeeded")

  results:
    - name: failed_info
      description: Info about failed build.
    - name: failed_task
      description: Name of a failed task.
    - name: failed_step
      description: Name of a failed step.
    - name: logs
      description: Failed pod logs.

  stepTemplate:
    envFrom:
      - configMapRef:
          name: $(params.application)-build-pipeline-config
      - secretRef:
          name: $(params.application)-slack-secret  # used for webhook URL

    env:
      - name: POD_NAME
        valueFrom:
          fieldRef:
            fieldPath: metadata.name
    volumeMounts:
      - name: podinfo
        mountPath: /etc/podinfo

  steps:
    - name: get-failed-info
      image: bitnami/kubectl:1.22.10
      imagePullPolicy: IfNotPresent
      script: |
        #!/bin/sh

        pipelinerun_name=$(awk -F= '/tekton.dev\/pipelineRun/ {gsub(/"/, "", $2);print $2}' /etc/podinfo/labels)

        # get failed info from pipelinerun name
        kubectl -n ci get pipelinerun $pipelinerun_name -o json |
          jq '[.status.taskRuns | to_entries[] | select ( .value.status.conditions[0].reason == "Failed") |
          { task: .value.pipelineTaskName, pod: .value.status.podName, steps: .value.status.steps[] } |
          select (.steps.terminated.reason == "Error")][0] | { task: .task, pod: .pod, step: .steps.name }' \
          > $(results.failed_info.path)

        failed_pod_name=$(cat $(results.failed_info.path) | jq '.pod' -r)
        failed_task=$(cat $(results.failed_info.path) | jq '.task' -r)
        failed_step=$(cat $(results.failed_info.path) | jq '.step' -r)

        if [ "$failed_pod_name" != "null" ] && [ "$failed_step" != "null" ]; then
          kubectl -n ci logs $failed_pod_name -c step-$failed_step | tail -c 1982 > $(results.logs.path)
          echo $failed_task > $(results.failed_task.path)
          echo $failed_step > $(results.failed_step.path)
        fi

    - name: notification
      image: cloudposse/slack-notifier:0.4.0
      imagePullPolicy: IfNotPresent
      script: |
        #!/bin/sh

        # tekton injects these labels into pods
        # https://tekton.dev/docs/pipelines/labels/
        # so we can easily extract items
        # podinfo is mounted in TriggerTemplate
        pipelinerun_name=$(awk -F= '/tekton.dev\/pipelineRun/ {gsub(/"/, "", $2);print $2}' /etc/podinfo/labels)
        status="`echo $(params.status) | tr '[:upper:]' '[:lower:]'`"

        echo "result: $status"

        if [ "$status" = "succeeded" ]; then
          color="good"
          thumb_url="$(params.pusher_avatar)"
          text_status="The latest changes to $(params.environment) have been deployed successfully"

        else
          color="danger"
          thumb_url="$SLACK_FAILURE_ICON_URL"
          text_status="The latest changes to $(params.environment) failed to be deployed"
          failed_task=$(cat $(results.failed_task.path))
          failed_step=$(cat $(results.failed_step.path))
          failed="Task: $failed_task, Step: $failed_step"
          error_msg=$(tail -c 1982 $(results.logs.path))
        fi

        argo_app_url="$ARGOCD_SERVER/$ARGOCD_ROOT_PATH/applications/$(params.application)"
        argo_app_url=$(echo $argo_app_url | sed 's/\/\//\//g')
        argo_app_url="https://$argo_app_url"

        # Preparing jira links
        # We are using grep as ash doesn't support regex test
        jira_task=$(echo "$(params.head_commit_message)" | grep -oE '[A-Z0-9]+-[0-9]+' | head -n 1 )
        if [ "$jira_task" != "" ];
        then
          echo "Found $jira_task jira task, preparing link"
          head_commit_message=$(echo "$(params.head_commit_message)" | sed "s|$jira_task|\<https://saritasa.atlassian.net/browse/$jira_task/\|$jira_task\>|")
        else
          echo "No jira task found";
          head_commit_message="$(params.head_commit_message)"
        fi


        slack-notifier \
        -user_name "Tekton" \
        -icon_emoji ":white_check_mark:" \
        -color "$color" \
        -author_name "[$(params.application)] by $(params.pusher_name)" \
        -author_link "$(params.pusher_url)" \
        -title "$head_commit_message" \
        -text "$text_status" \
        -thumb_url "$thumb_url" \
        -field1_title "Open Application" \
        -field1_value "<$APPLICATION_URL|$APPLICATION_URL>" \
        -field1_short false \
        -field2_title "Branch" \
        -field2_value "$(echo $(params.branch) | sed -r 's/\brefs\/\bheads\///g')" \
        -field2_short true \
        -field3_title "Revision" \
        -field3_value "<$(params.repository_url)/commit/$(params.sha)|$(params.sha)>" \
        -field3_short true \
        -field4_title "Manage" \
        -field4_value "<$(params.repository_url)|Github> | <$(params.repository_url)/issues|Issues> | <$JIRA_PROJECT_URL|Jira> | <$TEKTON_URL/$pipelinerun_name|CI> | <$argo_app_url|CD> " \
        -field4_short false \
        -field5_title "Failure info" \
        -field5_value "$failed" \
        -field5_short false \
        -field6_title "Traceback" \
        -field6_value "$error_msg" \
        -field6_short false
---
# Source: saritasa-tekton-pipelines/templates/kaniko/tasks/kaniko.yaml
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: kaniko
  namespace: default

spec:
  description: >-
    This is task for legacy Saritasa projects written with Dockerfile, compilation is done by using Kaniko
    https://www.baeldung.com/ops/kaniko

  workspaces:
    - name: source

  params:
    - name: application
      type: string
      description: name of the argocd application we're going to deploy/sync

    - name: image_registry
      type: string
      description: aws private ecr registry address

    - name: docker_file
      type: string
      description: name of the dockerfile
      default: "Dockerfile"

    - name: docker_context
      type: string
      description: |
        The build context used by Kaniko
        (https://github.com/GoogleContainerTools/kaniko#kaniko-build-contexts)
      default: "."

    - name: extra_args
      type: array
      description: extra args to be passed into kaniko builder
      default: []

    - name: environment
      type: string
      description: environment name of the app being built, i.e. dev/staging/prod

    - name: app_image
      type: string
      description: result app image url

  results:
    - name: password
      description: The password to authenticate to ecr registry.
    # - name: app_image_digest
    #   description: result app image digest

  stepTemplate:
    envFrom:
      - configMapRef:
          name: $(params.application)-build-pipeline-config # project specific values

  steps:
    - name: authenticate
      image: docker.io/amazon/aws-cli:2.7.4
      imagePullPolicy: IfNotPresent
      workingDir: $(workspaces.source.path)
      script: |
        #!/bin/bash
        aws ecr get-login-password --region $AWS_REGION > $(results.password.path)

    - name: build
      image: gcr.io/kaniko-project/executor:latest
      imagePullPolicy: IfNotPresent
      workingDir: $(workspaces.source.path)
      env:
        - name: "DOCKER_CONFIG"
          value: "/tekton/home/.docker/"
      command:
        - /kaniko/executor
      args:
        - $(params.extra_args[*])
        - --build-arg=ENVIRONMENT=$(params.environment)
        - --dockerfile=$(params.registry_file)
        - --context=$(workspaces.source.path)/$(params.registry_context)
        - --destination=$(params.app_image)
        # - --digest-file=$(results.app_image_digest.path)
        # - --verbosity=debug

      volumeMounts:
        - name: layers-dir
          mountPath: /layers

      # kaniko assumes it is running as root, which means this example fails on platforms
      # that default to run containers as random uid (like OpenShift). Adding this securityContext
      # makes it explicit that it needs to run as root.
      securityContext:
        runAsUser: 0
---
# Source: saritasa-tekton-pipelines/templates/kaniko/tasks/post-deploy.yaml
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: kaniko-post-deploy
  namespace: default

spec:
  description: >-
    Task performs custom post deploy actions, which are set from values.yaml
    (for ex. run selenium tests or etc)

  params:

    - name: application
      type: string
      description: name of the argocd application we're going to deploy/sync

    - name: project
      type: string
      description: name of the project, which component is deployed

    - name: namespace
      type: string
      description: project's namespace

    - name: sha
      type: string
      description: sha commit ID of the image deployed in cluster

    - name: environment
      type: string
      description: environment name of the app being built, i.e. dev/staging/prod

  stepTemplate:
    envFrom:
      - configMapRef:
          name: $(params.application)-build-pipeline-config # project specific values

  steps:
    - name: argo-events
      image: badouralix/curl-jq
      imagePullPolicy: IfNotPresent
      script: |
        #!/usr/bin/env sh

        # Env contains params passed from '*-build-pipeline-config' ConfigMap,
        # here we convert them to lowercased json and pass to JSON_PAYLOAD as 'extra'.

        # This workflow allows us to pass any dynamic custom parameters needed to argo-events
        # sensors without changing tekton helm charts all the time, so any project may have
        # any custom parameter, which will be passed to argo-events and then corresponding Sensor
        # would be triggered based on this 'extra' params.
        EXTRA=$(jq -n env | jq 'walk(if type=="object" then with_entries(.key|=ascii_downcase) else . end)')
        JSON_TEMPLATE='{
          "namespace": "$(params.namespace)",
          "project": "$(params.project)",
          "environment": "$(params.environment)",
          "application": "$(params.application)",
          "sha": "$(params.sha)",
          "extra": %s
        }'
        JSON_PAYLOAD=$(printf "$JSON_TEMPLATE" "$EXTRA")

        echo "Payload: $JSON_PAYLOAD"

        OUTPUT=$(curl -s -o /dev/null -w httpcode=%{http_code} --location \
          --request POST "build-succeed-eventsource-svc.argo-events.svc.cluster.local:12000/build-succeed" \
          --header 'Content-Type: application/json' \
          --data-raw "$JSON_PAYLOAD")

        STATUS_CODE=$(echo "${OUTPUT}" | sed -e 's/.*\httpcode=//')
        if [ ${STATUS_CODE} -ne 204 ] && [ ${STATUS_CODE} -ne 200 ]; then
            echo "Curl operation/command failed due to server return code - ${STATUS_CODE}"
            exit 0
        fi

        echo "Sent 'build-succeed' webhook"

  # insert customized steps as defined in the values.yaml of the helm chart
---
# Source: saritasa-tekton-pipelines/templates/common/triggers/github-trigger-binding.yaml
apiVersion: triggers.tekton.dev/v1alpha1
kind: TriggerBinding
metadata:
  name: github-trigger-binding
  namespace: default
spec:
  params:
  - name: head_commit
    value: $(body.head_commit.id)
  - name: head_commit_message
    value: $(body.head_commit.message)
  - name: pusher_name
    value: $(body.head_commit.author.name)
  - name: pusher_email
    value: $(body.pusher.email)
  - name: pusher_avatar
    value: $(body.sender.avatar_url)
  - name: pusher_url
    value: $(body.sender.html_url)
  - name: repository_name
    value: $(body.repository.full_name)
  - name: repository_url
    value: $(body.repository.html_url)
  - name: repository_ssh_url
    value: $(body.repository.ssh_url)
  - name: branch
    value: $(body.ref)
---
# Source: saritasa-tekton-pipelines/templates/buildpacks/trigger-templates/buildpack.yaml
apiVersion: triggers.tekton.dev/v1alpha1
kind: TriggerTemplate
metadata:
  name: buildpack-frontend-build-pipeline-trigger-template
  namespace: default
spec:

# ┌──────────────────────────────────────────────────────────────────────────────┐
# │ Parameters of the triggertemplate are pushed here based on triggerbindings   │
# │ objects                                                                      │
# │                                                                              │
# └──────────────────────────────────────────────────────────────────────────────┘
  params:

    - name: application
      description: name of the argocd application we're going to deploy/sync

    - name: sha
      description: sha commit ID of the image deployed in cluster

    - name: head_commit
      description: full SHA commit ID

    - name: head_commit_message
      description: description of the commit (by developer)

    - name: pusher_name
      description: author name

    - name: pusher_email
      description: author email

    - name: pusher_avatar
      description: author url avatar image

    - name: pusher_url
      description: author link to profile

    - name: repository_url
      description: git repository https url

    - name: environment
      description: environment name of the app being built, i.e. dev/staging/prod

    - name: project
      description: name of the project, which component is deployed

    - name: component
      description: name of the application component, which is deployed

    - name: branch
      description: git branch

    - name: image_registry
      description: private docker registry address

    - name: image_registry_repository
      description: private docker registry repository address

    - name: kubernetes_repository_ssh_url
      description: git repo for kustomize management

    - name: kubernetes_branch
      description: git branch for kustomize managed git repo

    - name: kubernetes_repository_kustomize_path
      description: overlay path for kustomize call

    - name: app_image
      description: reference to a app result image

    - name: namespace
      description: project's namespace

    - name: repository_ssh_url
      description: git repository ssh url

    - name: repository_submodules
      description: defines whether repository should be initialized with submodules or not (if false value is set, it means no repository submodules would be downloaded)
      default: "true"

    - name: buildpack_builder_image
      description: the image on which builds will run (must include lifecycle and compatible buildpacks).

    - name: buildpack_runner_image
      description: reference to a run image to use

    - name: source_subpath
      description: a subpath within the `source` input where the source to build is located.
      default: ""

    - name: buildpack_config_filename
      description: The name of the buildpack.yml file which should be used for build
      default: "buildpack.yml"

    - name: project_config_filename
      description: The name of the project.toml file which should be used for build
      default: "project.toml"

    - name: sentry_project_name
      description: name of the project in Sentry

  resourcetemplates:
  - kind: PipelineRun
    apiVersion: tekton.dev/v1beta1
    metadata:
      generateName: $(tt.params.application)-build-pipeline-run-
      labels:
        app: $(tt.params.application)
        project: $(tt.params.project)
        environment: $(tt.params.environment)
        component: $(tt.params.component)
    spec:
      serviceAccountName: $(tt.params.application)-build-pipeline-sa
      serviceAccountNames:
        - taskName: kustomize
          serviceAccountName: $(tt.params.application)-build-pipeline-kustomize-sa
      pipelineRef:
        name: buildpack-frontend-build-pipeline
      params:
        - name: "application"
          value: "$(tt.params.application)"
        - name: sha
          value: "$(tt.params.sha)"
        - name: head_commit
          value: "$(tt.params.head_commit)"
        - name: head_commit_message
          value: "$(tt.params.head_commit_message)"
        - name: pusher_name
          value: "$(tt.params.pusher_name)"
        - name: pusher_email
          value: "$(tt.params.pusher_email)"
        - name: pusher_avatar
          value: "$(tt.params.pusher_avatar)"
        - name: pusher_url
          value: "$(tt.params.pusher_url)"
        - name: repository_url
          value: "$(tt.params.repository_url)"
        - name: branch
          value: "$(tt.params.branch)"
        - name: image_registry
          value: "$(tt.params.image_registry)"
        - name: image_registry_repository
          value: "$(tt.params.image_registry_repository)"
        - name: kubernetes_repository_ssh_url
          value: "$(tt.params.kubernetes_repository_ssh_url)"
        - name: kubernetes_repository_kustomize_path
          value: "$(tt.params.kubernetes_repository_kustomize_path)"
        - name: kubernetes_branch
          value: "$(tt.params.kubernetes_branch)"
        - name: app_image
          value: "$(tt.params.image_registry_repository):$(tt.params.environment)-$(tt.params.sha)"
        - name: environment
          value: "$(tt.params.environment)"
        - name: project
          value: "$(tt.params.project)"
        - name: namespace
          value: "$(tt.params.namespace)"
        - name: buildpack_builder_image
          value: "$(tt.params.buildpack_builder_image)"
        - name: buildpack_runner_image
          value: "$(tt.params.buildpack_runner_image)"
        - name: app_image
          value: "$(tt.params.image_registry_repository):$(tt.params.environment)-$(tt.params.sha)"
        - name: source_subpath
          value: "$(tt.params.source_subpath)"
        - name: repository_submodules
          value: "$(tt.params.repository_submodules)"
        - name: buildpack_config_filename
          value: "$(tt.params.buildpack_config_filename)"
        - name: project_config_filename
          value: "$(tt.params.project_config_filename)"
        - name: sentry_project_name
          value: "$(tt.params.sentry_project_name)"

      workspaces:
        - name: app-source
          persistentVolumeClaim:
            claimName: $(tt.params.application)-workspace-pvc
        - name: k8s-source
          volumeClaimTemplate:
            spec:
              accessModes:
              - ReadWriteOnce
              resources:
                requests:
                  storage: 2Gi
      taskRunTemplate:
        podTemplate:
          volumes:
          - name: $(tt.params.application)-buildpacks-cache
            persistentVolumeClaim:
              claimName: $(tt.params.application)-buildpacks-cache-pvc
          - name: podinfo
            downwardAPI:
              items:
                - path: "labels"
                  fieldRef:
                    fieldPath: metadata.labels
                - path: "annotations"
                  fieldRef:
                    fieldPath: metadata.annotations

          nodeSelector:
            ci: "true"
          tolerations:
          - effect: NoSchedule
            key: ci
            operator: Equal
            value: "true"
---
# Source: saritasa-tekton-pipelines/templates/kaniko/trigger-template.yaml
apiVersion: triggers.tekton.dev/v1alpha1
kind: TriggerTemplate
metadata:
  name: kaniko-build-pipeline-trigger-template
  namespace: default
spec:
  params:

    - name: application
      description: name of the argocd application we're going to deploy/sync

    - name: sha
      description: sha commit ID of the image deployed in cluster

    - name: head_commit
      description: full SHA commit ID

    - name: head_commit_message
      description: description of the commit (by developer)

    - name: pusher_name
      description: author name

    - name: pusher_email
      description: author email

    - name: pusher_avatar
      description: author url avatar image

    - name: pusher_url
      description: author link to profile

    - name: repository_url
      description: git repository https url

    - name: environment
      description: environment name of the app being built, i.e. dev/staging/prod

    - name: project
      description: name of the project, which component is deployed

    - name: component
      description: name of the application component, which is deployed

    - name: branch
      description: git branch

    - name: image_registry
      description: private docker registry address

    - name: image_registry_repository
      description: private docker registry repository address

    - name: kubernetes_repository_ssh_url
      description: git repo for kustomize management

    - name: kubernetes_branch
      description: git branch for kustomize managed git repo

    - name: kubernetes_repository_kustomize_path
      description: overlay path for kustomize call

    - name: app_image
      description: reference to a app result image

    - name: namespace
      description: project's namespace

    - name: repository_ssh_url
      description: git repository ssh url

    - name: repository_submodules
      description: defines whether repository should be initialized with submodules or not (if false value is set, it means no repository submodules would be downloaded)
      default: "true"

    - name: docker_file
      default: Dockerfile
      description: location of the dockerfile, should be Dockerfile if it is in the root of the repository

    - name: docker_context
      default: "."
      description: dockerfile context path

    - name: kaniko_extra_args
      default: ''
      description: additional arguments to pass to 'kaniko build' (similar to 'docker build')

    - name: sentry_project_name
      description: name of the project in Sentry

  resourcetemplates:
  - kind: PipelineRun
    apiVersion: tekton.dev/v1beta1
    metadata:
      generateName: $(tt.params.application)-kaniko-build-pipeline-run-
      labels:
        app: $(tt.params.application)
        project: $(tt.params.project)
        environment: $(tt.params.environment)
        component: $(tt.params.component)
    spec:
      serviceAccountName: $(tt.params.application)-build-pipeline-sa
      serviceAccountNames:
        - taskName: kustomize
          serviceAccountName: $(tt.params.application)-build-pipeline-kustomize-sa
      pipelineRef:
        name: kaniko-build-pipeline
      params:
        - name: "application"
          value: "$(tt.params.application)"
        - name: sha
          value: "$(tt.params.sha)"
        - name: head_commit
          value: "$(tt.params.head_commit)"
        - name: head_commit_message
          value: "$(tt.params.head_commit_message)"
        - name: pusher_name
          value: "$(tt.params.pusher_name)"
        - name: pusher_email
          value: "$(tt.params.pusher_email)"
        - name: pusher_avatar
          value: "$(tt.params.pusher_avatar)"
        - name: pusher_url
          value: "$(tt.params.pusher_url)"
        - name: repository_url
          value: "$(tt.params.repository_url)"
        - name: branch
          value: "$(tt.params.branch)"
        - name: image_registry
          value: "$(tt.params.image_registry)"
        - name: image_registry_repository
          value: "$(tt.params.image_registry_repository)"
        - name: kubernetes_repository_ssh_url
          value: "$(tt.params.kubernetes_repository_ssh_url)"
        - name: kubernetes_repository_kustomize_path
          value: "$(tt.params.kubernetes_repository_kustomize_path)"
        - name: kubernetes_branch
          value: "$(tt.params.kubernetes_branch)"
        - name: app_image
          value: "$(tt.params.image_registry_repository):$(tt.params.environment)-$(tt.params.sha)"
        - name: environment
          value: "$(tt.params.environment)"
        - name: project
          value: "$(tt.params.project)"
        - name: namespace
          value: "$(tt.params.namespace)"
        - name: docker_file
          value: "$(tt.params.registry_file)"
        - name: docker_context
          value: "$(tt.params.registry_context)"
        - name: kaniko_extra_args
          value: "$(tt.params.kaniko_extra_args)"
        - name: repository_submodules
          value: "$(tt.params.repository_submodules)"
        - name: sentry_project_name
          value: "$(tt.params.sentry_project_name)"

      workspaces:
        - name: app-source
          persistentVolumeClaim:
            claimName: $(tt.params.application)-workspace-pvc
        - name: k8s-source
          volumeClaimTemplate:
            spec:
              accessModes:
              - ReadWriteOnce
              resources:
                requests:
                  storage: 2Gi
      taskRunTemplate:
        podTemplate:
          volumes:
          - name: podinfo
            downwardAPI:
              items:
                - path: "labels"
                  fieldRef:
                    fieldPath: metadata.labels
                - path: "annotations"
                  fieldRef:
                    fieldPath: metadata.annotations

          nodeSelector:
            ci: "true"
          tolerations:
          - effect: NoSchedule
            key: ci
            operator: Equal
            value: "true"
